{
  "subject": "TypeScript",
  "version": "1.0",
  "totalQuestions": 100,
  "categories": [
    {
      "id": "fundamentals",
      "title": "TypeScript Fundamentals",
      "questions": [
        { "id": 1, "question": "What is TypeScript?", "answer": "TypeScript is a statically typed superset of JavaScript that compiles to JavaScript." },
        { "id": 2, "question": "Why use TypeScript instead of JavaScript?", "answer": "It adds static typing, better tooling, and improved maintainability." },
        { "id": 3, "question": "Is TypeScript compiled or interpreted?", "answer": "Compiled (transpiled) to JavaScript." },
        { "id": 4, "question": "Does TypeScript run directly in the browser?", "answer": "No, it must be compiled to JavaScript first." },
        { "id": 5, "question": "What are basic TypeScript types?", "answer": "string, number, boolean, null, undefined, any, unknown, void, never." },
        { "id": 6, "question": "What is the any type?", "answer": "A type that disables type checking." },
        { "id": 7, "question": "Why is any discouraged?", "answer": "It removes type safety and increases runtime errors." },
        { "id": 8, "question": "What is unknown?", "answer": "A safer alternative to any that requires type checks." },
        { "id": 9, "question": "Difference between null and undefined?", "answer": "null is an intentional absence; undefined means not assigned." },
        { "id": 10, "question": "What is type inference?", "answer": "TypeScript infers types automatically from values." },
        { "id": 11, "question": "What is a tuple?", "answer": "A fixed-length array with typed positions." },
        { "id": 12, "question": "What is an enum?", "answer": "A named set of constant values." },
        { "id": 13, "question": "Numeric vs string enums?", "answer": "Numeric enums auto-increment; string enums require explicit values." },
        { "id": 14, "question": "What is void?", "answer": "A return type indicating no value." },
        { "id": 15, "question": "What is never?", "answer": "A type for values that never occur." },
        { "id": 16, "question": "What is strict mode?", "answer": "A compiler configuration enforcing stricter type checks." },
        { "id": 17, "question": "What is tsconfig.json?", "answer": "Configuration file for TypeScript compiler options." },
        { "id": 18, "question": "What does noImplicitAny do?", "answer": "Disallows implicit any types." },
        { "id": 19, "question": "What does strictNullChecks enforce?", "answer": "Explicit handling of null and undefined." },
        { "id": 20, "question": "Can TypeScript be used incrementally?", "answer": "Yes, it can be gradually adopted." }
      ]
    },
    {
      "id": "interfaces_types",
      "title": "Interfaces and Types",
      "questions": [
        { "id": 21, "question": "What is an interface?", "answer": "A contract describing object structure." },
        { "id": 22, "question": "Interface vs type?", "answer": "Interfaces support merging; types support unions and intersections." },
        { "id": 23, "question": "Can interfaces be merged?", "answer": "Yes." },
        { "id": 24, "question": "Can type aliases be merged?", "answer": "No." },
        { "id": 25, "question": "Can interfaces define function signatures?", "answer": "Yes." },
        { "id": 26, "question": "Can interfaces extend multiple interfaces?", "answer": "Yes." },
        { "id": 27, "question": "What is a union type?", "answer": "A type allowing multiple possible values." },
        { "id": 28, "question": "What is an intersection type?", "answer": "A combination of multiple types." },
        { "id": 29, "question": "What is a literal type?", "answer": "A type representing a specific value." },
        { "id": 30, "question": "What is a discriminated union?", "answer": "A union using a common literal property for narrowing." },
        { "id": 31, "question": "What is structural typing?", "answer": "Type compatibility based on shape." },
        { "id": 32, "question": "What is an optional property?", "answer": "A property that may be omitted." },
        { "id": 33, "question": "What does readonly do?", "answer": "Prevents reassignment." },
        { "id": 34, "question": "Interface vs class?", "answer": "Interfaces define shape; classes implement behavior." },
        { "id": 35, "question": "Can classes implement multiple interfaces?", "answer": "Yes." },
        { "id": 36, "question": "What is an index signature?", "answer": "Defines dynamic object keys." },
        { "id": 37, "question": "What is excess property checking?", "answer": "Checks unexpected properties on object literals." }
      ]
    },
    {
      "id": "functions_generics",
      "title": "Functions and Generics",
      "questions": [
        { "id": 38, "question": "How do you type a function?", "answer": "By typing parameters and return value." },
        { "id": 39, "question": "What is function overloading?", "answer": "Multiple signatures with one implementation." },
        { "id": 40, "question": "What are optional parameters?", "answer": "Parameters that may be omitted." },
        { "id": 41, "question": "What are default parameters?", "answer": "Parameters with default values." },
        { "id": 42, "question": "What are rest parameters?", "answer": "Parameters capturing multiple arguments." },
        { "id": 43, "question": "What are generics?", "answer": "Reusable components working with multiple types." },
        { "id": 44, "question": "Why use generics?", "answer": "To maintain type safety while reusing logic." },
        { "id": 45, "question": "Generic syntax example?", "answer": "function identity<T>(arg: T): T" },
        { "id": 46, "question": "What is a generic constraint?", "answer": "Limits generic types using extends." },
        { "id": 47, "question": "What is keyof?", "answer": "Creates a union of object keys." },
        { "id": 48, "question": "What is typeof?", "answer": "Extracts a type from a value." },
        { "id": 49, "question": "What is a conditional type?", "answer": "A type based on a condition." },
        { "id": 50, "question": "What does infer do?", "answer": "Infers a type inside conditional types." },
        { "id": 51, "question": "What is a higher-order function?", "answer": "A function that takes or returns another function." },
        { "id": 52, "question": "Can generics have default values?", "answer": "Yes." },
        { "id": 53, "question": "What is polymorphism?", "answer": "Ability to work with multiple types via generics." },
        { "id": 54, "question": "What is variance?", "answer": "Rules governing subtype relationships." },
        { "id": 55, "question": "Are function parameters bivariant?", "answer": "Yes, by default." }
      ]
    },
    {
      "id": "advanced_types",
      "title": "Advanced Types",
      "questions": [
        { "id": 56, "question": "What is Partial<T>?", "answer": "Makes all properties optional." },
        { "id": 57, "question": "What is Required<T>?", "answer": "Makes all properties required." },
        { "id": 58, "question": "What is Readonly<T>?", "answer": "Makes all properties immutable." },
        { "id": 59, "question": "What is Pick<T, K>?", "answer": "Selects specific properties." },
        { "id": 60, "question": "What is Omit<T, K>?", "answer": "Removes specific properties." },
        { "id": 61, "question": "What is Record<K, T>?", "answer": "Creates a key-value object type." },
        { "id": 62, "question": "What is a mapped type?", "answer": "Transforms properties of a type." },
        { "id": 63, "question": "What is a template literal type?", "answer": "A type created using string literals." },
        { "id": 64, "question": "What does as const do?", "answer": "Prevents type widening." },
        { "id": 65, "question": "What is type assertion?", "answer": "Tells the compiler to treat a value as a specific type." },
        { "id": 66, "question": "Type assertion vs casting?", "answer": "Assertions are compile-time only." },
        { "id": 67, "question": "unknown vs any?", "answer": "unknown enforces type checks." },
        { "id": 68, "question": "What is non-null assertion?", "answer": "Asserts a value is not null or undefined." },
        { "id": 69, "question": "What is exhaustiveness checking?", "answer": "Ensures all union cases are handled." },
        { "id": 70, "question": "What is the satisfies operator?", "answer": "Checks compatibility without widening." },
        { "id": 71, "question": "What is type widening?", "answer": "Inference becoming more general." },
        { "id": 72, "question": "What is type narrowing?", "answer": "Reducing a union type via checks." }
      ]
    },
    {
      "id": "ecosystem_practical",
      "title": "Practical Usage and Ecosystem",
      "questions": [
        { "id": 73, "question": "How does TypeScript work with React?", "answer": "By typing props, state, and hooks." },
        { "id": 74, "question": "How to type React props?", "answer": "Using interfaces or type aliases." },
        { "id": 75, "question": "How to type useState?", "answer": "By passing a generic type." },
        { "id": 76, "question": "How to type event handlers?", "answer": "Using React event types." },
        { "id": 77, "question": "How does TypeScript help refactoring?", "answer": "Compile-time error detection." },
        { "id": 78, "question": "How does TS integrate with Node.js?", "answer": "Using ts-node or build steps." },
        { "id": 79, "question": "What are declaration files?", "answer": "Files providing type definitions for JS libraries." },
        { "id": 80, "question": "What is DefinitelyTyped?", "answer": "A community repository of type definitions." },
        { "id": 81, "question": "What is module augmentation?", "answer": "Extending existing module types." },
        { "id": 82, "question": "What is path aliasing?", "answer": "Custom import paths via tsconfig." },
        { "id": 83, "question": "ES modules vs namespaces?", "answer": "ES modules are standard; namespaces are legacy." },
        { "id": 84, "question": "Does TypeScript affect tree-shaking?", "answer": "No, it is compile-time only." },
        { "id": 85, "question": "What is isolatedModules?", "answer": "Ensures each file is independently transpiled." },
        { "id": 86, "question": "What does esModuleInterop do?", "answer": "Improves CommonJS compatibility." },
        { "id": 87, "question": "What does skipLibCheck do?", "answer": "Skips type checking of declaration files." },
        { "id": 88, "question": "What are TS performance issues?", "answer": "Large unions and deep generics." },
        { "id": 89, "question": "What is incremental compilation?", "answer": "Faster builds using cached state." },
        { "id": 90, "question": "How does TS help large systems?", "answer": "Enforces contracts and reduces runtime bugs." },
        { "id": 91, "question": "Is TS worth it for small projects?", "answer": "Yes, for maintainability." },
        { "id": 92, "question": "What is branding in TypeScript?", "answer": "A workaround for nominal typing." },
        { "id": 93, "question": "What is recursive type?", "answer": "A type that references itself." },
        { "id": 94, "question": "What is utility type composition?", "answer": "Combining utility types." },
        { "id": 95, "question": "What is confidence scoring?", "answer": "Measuring consistency across answers." },
        { "id": 96, "question": "What is design judgment in TS?", "answer": "Choosing appropriate types and abstractions." },
        { "id": 97, "question": "What is over-engineering in TS?", "answer": "Using unnecessary complexity in types." },
        { "id": 98, "question": "What is hire readiness?", "answer": "Assessment of job-level capability." },
        { "id": 99, "question": "How does TS improve DX?", "answer": "Autocomplete, refactoring, and tooling." },
        { "id": 100, "question": "What defines a senior TS engineer?", "answer": "Deep type system knowledge and architectural judgment." }
      ]
    }
  ]
}
